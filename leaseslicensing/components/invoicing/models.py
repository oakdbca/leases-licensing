import logging
import math
import uuid
from datetime import date, datetime
from decimal import Decimal
from typing import Union

from dateutil.relativedelta import relativedelta
from django.conf import settings
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models, transaction
from django.db.models import F, Q, Sum, Window
from django.db.models.functions import Coalesce
from django.forms import ValidationError
from django.utils import timezone
from rest_framework import serializers

from leaseslicensing import helpers
from leaseslicensing.components.invoicing import utils
from leaseslicensing.components.invoicing.email import (
    send_new_invoice_raised_internal_notification,
    send_new_invoices_raised_internal_notification,
)
from leaseslicensing.components.main.models import (
    LicensingModel,
    RevisionedMixin,
    SecureFileField,
)

logger = logging.getLogger(__name__)


class BaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True, null=True)
    modified_at = models.DateTimeField(auto_now=True, null=True)

    class Meta:
        abstract = True


class ChargeMethod(models.Model):
    key = models.CharField(max_length=200, unique=True)
    display_name = models.CharField(
        max_length=200,
    )
    display_order = models.IntegerField(default=0)

    class Meta:
        app_label = "leaseslicensing"
        ordering = ["display_order"]

    def __str__(self):
        return self.display_name


class RepetitionType(models.Model):
    key = models.CharField(max_length=200, unique=True)
    display_name = models.CharField(
        max_length=200,
    )

    class Meta:
        app_label = "leaseslicensing"
        ordering = ["id"]

    def __str__(self):
        return self.display_name


class ConsumerPriceIndex(BaseModel):
    year = models.PositiveSmallIntegerField(null=True)
    quarter = models.PositiveSmallIntegerField(
        null=True, help_text="1 = MAR, 2 = JUN, 3 = SEP, 4 = DEC"
    )
    value = models.DecimalField(
        max_digits=20,
        decimal_places=1,
        help_text="Percentage Change from Corresponding Quarter of the Previous Year",
    )
    datetime_created = models.DateTimeField(auto_now_add=True)

    class Meta:
        app_label = "leaseslicensing"
        verbose_name = "CPI Data (Perth - All Groups)"
        verbose_name_plural = "CPI Data (Perth - All Groups)"
        ordering = ["-year", "-quarter"]

    def __str__(self):
        return f"{self.year}-Q{self.quarter}: {self.value}"

    @classmethod
    def get_most_recent_quarter(cls, quarter):
        return cls.objects.filter(quarter=quarter).order_by("-year", "-quarter").first()

    @classmethod
    def get_most_recent_quarter_by_date(
        cls, date: datetime | date, quarter: int
    ) -> Union["ConsumerPriceIndex", None]:
        if isinstance(date, datetime):
            date = date.date()
        year = date.year
        end_of_quarter_month = utils.month_from_cpi_quarter(quarter)
        if end_of_quarter_month > date.month:
            year -= 1
        recent_quarter = cls.objects.filter(year=year, quarter=quarter).first()
        if not recent_quarter:
            logger.info(
                f"CPI data for {year}-Q{quarter} not yet available but will be available before supplied date: {date}"
            )

        return recent_quarter


class CPICalculationMethod(models.Model):
    name = models.CharField(max_length=255, null=False, blank=False, editable=False)
    display_name = models.CharField(max_length=255, null=False, blank=False)
    quarter = models.PositiveSmallIntegerField(
        null=True, help_text="1 = MAR, 2 = JUN, 3 = SEP, 4 = DEC"
    )
    archived = models.BooleanField(default=False)

    class Meta:
        app_label = "leaseslicensing"
        verbose_name = "CPI Calculation Method"
        verbose_name_plural = "CPI Calculation Methods"

    def __str__(self):
        return f"{self.display_name}"


class OracleCode(models.Model):
    code = models.CharField(max_length=50, null=False, blank=False)
    description = models.CharField(max_length=200, null=True, blank=True)

    class Meta:
        app_label = "leaseslicensing"
        ordering = ["code"]

    def __str__(self):
        return f"{self.code}"


class InvoicingDetailsManager(models.Manager):
    def get_queryset(self):
        return (
            super()
            .get_queryset()
            .prefetch_related(
                "annual_increment_amounts",
                "annual_increment_percentages",
                "gross_turnover_percentages",
            )
        )


class InvoicingDetails(BaseModel):
    """
    This is the main model to store invoicing details, generated by a proposal first
    (Proposal has a field: invoicing_details)
    then copied and/or edited as business run
    """

    objects = InvoicingDetailsManager()

    charge_method = models.ForeignKey(
        ChargeMethod, null=True, blank=True, on_delete=models.SET_NULL
    )
    base_fee_amount = models.DecimalField(
        max_digits=10, decimal_places=2, null=True, blank=True
    )
    once_off_charge_amount = models.DecimalField(
        max_digits=10, decimal_places=2, null=True, blank=True
    )
    review_once_every = models.PositiveSmallIntegerField(
        null=True, blank=True, default=5
    )
    review_repetition_type = models.ForeignKey(
        RepetitionType,
        null=True,
        blank=True,
        on_delete=models.PROTECT,
        related_name="invoicing_details_set_for_review",
    )
    invoicing_once_every = models.PositiveSmallIntegerField(
        null=True, blank=True, default=1
    )
    invoicing_repetition_type = models.ForeignKey(
        RepetitionType,
        null=True,
        blank=True,
        on_delete=models.PROTECT,
        related_name="invoicing_details_set_for_invoicing",
    )
    invoicing_day_of_month = models.PositiveSmallIntegerField(
        validators=[
            MinValueValidator(1),
            MaxValueValidator(28),
        ],
        help_text="Day of the month to generate invoices.",
        null=True,
        blank=True,
    )
    invoicing_month_of_year = models.PositiveSmallIntegerField(
        validators=[
            MinValueValidator(1),
            MaxValueValidator(12),
        ],
        help_text="Month of the year to generate invoices.",
        null=True,
        blank=True,
    )
    # Used to support legacy leases/licenses that have an unusual quarterly invoicing cycle
    # Can be 1, 2 or 3. 1 = [JAN, APR, JUL, OCT], 2 = [FEB, MAY, AUG, NOV], 3 = [MAR, JUN, SEP, DEC]
    invoicing_quarters_start_month = models.PositiveSmallIntegerField(
        null=True,
        blank=True,
        default=3,
    )
    previous_invoicing_details = models.OneToOneField(
        "self",
        null=True,
        blank=True,
        related_name="next_invoicing_details",
        on_delete=models.SET_NULL,
    )
    cpi_calculation_method = models.ForeignKey(
        CPICalculationMethod,
        null=True,
        blank=True,
        on_delete=models.PROTECT,
        related_name="invoicing_details",
    )
    oracle_code = models.ForeignKey(
        OracleCode,
        null=True,
        blank=True,
        on_delete=models.PROTECT,
        related_name="invoicing_details",
    )

    class Meta:
        app_label = "leaseslicensing"

    def __str__(self):
        proposal = self.approval.current_proposal if self.approval else None
        return f"Invoicing Details {self.id} for Approval: {self.approval} (Current Proposal: {proposal})"

    @property
    def approval(self):
        if not hasattr(self, "proposal") or not self.proposal:
            return None
        if not hasattr(self.proposal, "approval") or not self.proposal.approval:
            return None

        return self.proposal.approval

    @property
    def total_invoice_count(self):
        return len(self.invoicing_periods)

    @property
    def invoices_created(self):
        return (
            Invoice.objects.filter(approval=self.proposal.approval)
            .exclude(status=Invoice.INVOICE_STATUS_VOID)
            .count()
        )

    @property
    def invoices_yet_to_be_generated(self):
        return self.total_invoice_count - self.invoices_created

    @property
    def invoicing_periods(self):
        """Returns an array of invoicing periods based on the invoicing details object"""
        invoicing_periods = []

        if not self.charge_method or self.charge_method.key in [
            settings.CHARGE_METHOD_ONCE_OFF_CHARGE,
            settings.CHARGE_METHOD_NO_RENT_OR_LICENCE_CHARGE,
        ]:
            return invoicing_periods

        start_date = self.approval.start_date
        expiry_date = self.approval.expiry_date
        end_of_next_interval = self.get_end_of_next_interval(start_date)
        while end_of_next_interval <= expiry_date:
            delta = end_of_next_interval - start_date
            days = delta.days + 1  # The plus one to include the expiry day
            label = (
                f"{start_date.strftime('%d/%m/%Y')} to "
                f"{end_of_next_interval.strftime('%d/%m/%Y')} ({days} days)"
            )
            invoicing_periods.append(
                {
                    "label": label,
                    "start_date": start_date.strftime("%Y-%m-%d"),
                    "end_date": end_of_next_interval.strftime("%Y-%m-%d"),
                    "days": days,
                }
            )
            start_date = end_of_next_interval + relativedelta(days=1)
            end_of_next_interval = self.get_end_of_next_interval(start_date)

        # Check if a final period is required
        if start_date < expiry_date:
            delta = expiry_date - start_date
            days = delta.days + 1  # The plus one to include the expiry day
            invoicing_periods.append(
                {
                    "label": f"{start_date.strftime('%d/%m/%Y')} to {expiry_date.strftime('%d/%m/%Y')} ({days} days)",
                    "start_date": start_date.strftime("%Y-%m-%d"),
                    "end_date": expiry_date.strftime("%Y-%m-%d"),
                    "days": days,
                }
            )

        return invoicing_periods

    @property
    def invoicing_periods_start_dates(self):
        return [
            datetime.strptime(period["start_date"], "%Y-%m-%d").date()
            for period in self.invoicing_periods
        ]

    @property
    def preview_invoices_issue_dates(self):
        return [period["issue_date"] for period in self.preview_invoices]

    @property
    def invoice_schedule_original_issue_dates(self):
        return [period["original_issue_date"] for period in self.invoice_schedule()]

    @property
    def custom_cpi_reminder_dates(self) -> list[date] | None:
        if not self.has_future_invoicing_periods:
            return None

        seen = set()
        for issue_date in self.preview_invoices_issue_dates:
            issue_date = datetime.strptime(issue_date, "%d/%m/%Y").date()
            reminder_date_1 = issue_date - relativedelta(
                days=settings.CUSTOM_CPI_REMINDER_DAYS_PRIOR_TO_INVOICE_ISSUE_DATE[0]
            )
            reminder_date_2 = issue_date - relativedelta(
                days=settings.CUSTOM_CPI_REMINDER_DAYS_PRIOR_TO_INVOICE_ISSUE_DATE[1]
            )
            if reminder_date_1 not in seen:
                seen.add(reminder_date_1)
                yield reminder_date_1

            if reminder_date_2 not in seen:
                seen.add(reminder_date_2)
                yield reminder_date_2

    def preview_invoice_by_original_issue_date(self, date):
        date = datetime.strftime(date, "%d/%m/%Y")
        for invoice in self.invoice_schedule():
            if invoice["original_issue_date"] == date:
                return invoice
        return None

    @property
    def invoices_due_for_issue_today(self):
        invoices_due_today = [
            period
            for period in self.preview_invoices
            if datetime.strptime(period["original_issue_date"], "%d/%m/%Y").date()
            == helpers.today()
        ]

        # Make sure the system has not generated any invoices for the same approval
        # and same amount today as they will most likely be duplicates
        for invoice in invoices_due_today.copy():
            if Invoice.objects.filter(
                approval=self.approval,
                amount=invoice["amount_object"]["amount"],
            ).exists():
                logger.warning(
                    f"Suspected duplicate invoice skipped for approval: {self.approval}"
                )
                invoices_due_today.remove(invoice)

        return invoices_due_today

    @property
    def invoicing_periods_next_start_date(self):
        today = helpers.today()
        for start_date in self.invoicing_periods_start_dates:
            if start_date > today:
                return start_date
        return None

    @property
    def has_future_invoicing_periods(self):
        return self.invoicing_periods_next_start_date is not None

    @property
    def has_missing_gross_turnover_entries(self):
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE
        ):
            return self.gross_turnover_percentages.filter(
                estimated_gross_turnover__isnull=False,
                gross_turnover__isnull=True,
            ).exists()
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
        ):
            for gtp in self.gross_turnover_percentages.all():
                if gtp.financial_year_has_passed and gtp.gross_turnover is None:
                    return True

            return False

    @property
    def invoiced_up_to(self):
        # We return this if no invoices have been generated yet
        day_before_start_date = self.proposal.approval.start_date - relativedelta(
            days=1
        )
        if self.invoices_created == 0:
            return day_before_start_date

        # Most recent scheduled invoice that an invoice record has already been generated for
        most_recent_scheduled_invoice = ScheduledInvoice.objects.filter(
            invoicing_details=self, invoice__isnull=False
        ).last()
        if not most_recent_scheduled_invoice:
            return day_before_start_date

        return most_recent_scheduled_invoice.period_end_date

    @property
    def invoicing_periods_next_reminder_date(self):
        if not self.invoicing_periods_next_start_date:
            return None
        return self.invoicing_periods_next_start_date - relativedelta(
            days=settings.DAYS_BEFORE_NEXT_INVOICING_PERIOD_TO_GENERATE_INVOICE_RECORD
        )

    @property
    def get_custom_cpi_year_for_next_invoicing_period(self):
        today = helpers.today()
        index = None
        for i in range(0, len(self.invoicing_periods)):
            start_date = datetime.strptime(
                self.invoicing_periods[i]["start_date"], "%Y-%m-%d"
            ).date()
            if start_date >= today:
                index = i
                break

        return self.get_year_sequence_index(index)

    @property
    def custom_cpi_entered_for_next_invoicing_period(self):
        if (
            self.charge_method.key
            != settings.CHARGE_METHOD_BASE_FEE_PLUS_ANNUAL_CPI_CUSTOM
        ):
            logger.warning(
                f"custom_cpi_entered_for_next_period called for Invoicing Details: {self.id} "
                "which is not using custom CPI charge method. (Returning True so no reminder are sent)"
            )
            return (
                True  # Not strictly true but will prevent any reminders from being sent
            )

        custom_cpi_year = self.get_custom_cpi_year_for_next_invoicing_period
        custom_cpi_percentage = None
        try:
            custom_cpi_percentage = self.custom_cpi_years.all()[
                custom_cpi_year
            ].percentage
        # Either self has not custom_cpi_years attribute or the index is out of range
        except (AttributeError, IndexError):
            return False

        # The custom cpi percentage is None
        if custom_cpi_percentage is None:
            return False

        return True

    def invoice_schedule(self, include_past_periods=True):
        """
        Returns a full preview array of invoices based on the invoicing periods for the invoicing details object
        Including all past and future periods.
        """
        invoices = []
        days_running_total = 0
        amount_running_total = Decimal("0.00")
        issue_date = self.get_first_issue_date()
        number = 0
        for i, invoicing_period in enumerate(self.invoicing_periods):
            # Net 30 payment terms
            due_date = issue_date + relativedelta(days=30)
            days_running_total += invoicing_period["days"]

            issue_date_now_or_future = issue_date
            if issue_date < helpers.today():
                issue_date_now_or_future = helpers.today()

            amount_object = self.get_amount_for_invoice(
                issue_date_now_or_future,
                invoicing_period["start_date"],
                invoicing_period["end_date"],
                invoicing_period["days"],
                i,  # index needed to calculate the amount
            )

            # Find out if this is a backdated invoicing period
            start_date_has_passed = issue_date < timezone.now().date()
            end_date_has_passed = (
                datetime.strptime(invoicing_period["end_date"], "%Y-%m-%d").date()
                <= timezone.now().date()
            )

            # Skip adding the invoice if
            skip_adding = (
                # the proposal type is migration and the period is in the past
                self.proposal.proposal_type.code == settings.PROPOSAL_TYPE_MIGRATION
                and start_date_has_passed
            ) or (
                # the proposal is not in the approved editing invoicing status
                # (i.e. the user is editing from the approval page) and the period is in the past
                self.proposal.processing_status
                != self.proposal.PROCESSING_STATUS_APPROVED_EDITING_INVOICING
                and start_date_has_passed
            )

            if include_past_periods or not skip_adding:
                if amount_object["amount"]:
                    amount_running_total = (
                        amount_running_total + amount_object["amount"]
                    )
                else:
                    amount_running_total = amount_running_total + Decimal("0.00")

                number += 1  # Number only incremented for invoices that will be added to the preview
                invoices.append(
                    {
                        "number": number,
                        "original_issue_date": issue_date.strftime(
                            "%d/%m/%Y"
                        ),  # This is the issue date before it is changed to today if it is in the past
                        "issue_date": self.get_issue_date(
                            amount_object,
                            issue_date,
                            issue_date_now_or_future,
                            invoicing_period["end_date"],
                        ),
                        "due_date": self.get_due_date(due_date),
                        "time_period": invoicing_period["label"],
                        "start_date": invoicing_period["start_date"],
                        "end_date": invoicing_period["end_date"],
                        "amount_object": amount_object,
                        "days": invoicing_period["days"],
                        "days_running_total": days_running_total,
                        "amount_running_total": amount_running_total.quantize(
                            Decimal("0.01")
                        ),
                        "start_date_has_passed": start_date_has_passed,
                        "end_date_has_passed": end_date_has_passed,
                    }
                )

            if i < len(self.invoicing_periods) - 1:
                issue_date = self.add_repetition_interval(issue_date)
            else:
                # The last issue date is the day after the expiry date for the approval
                issue_date = self.approval.expiry_date + relativedelta(days=1)

        return invoices

    @property
    def preview_invoices(self):
        """
        Returns a preview array of invoices based on the invoicing periods for the invoicing details object
        To be used on the front end invoice previewer. Will exclude past preview invoiced under certain conditions.
        """
        return self.invoice_schedule(include_past_periods=False)

    def generate_invoice_schedule(self, invoiced_up_to=None):
        """Generate scheduled invoices for any invoicing periods"""
        if self.charge_method.key in [
            settings.CHARGE_METHOD_NO_RENT_OR_LICENCE_CHARGE,
            settings.CHARGE_METHOD_ONCE_OFF_CHARGE,
            settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS,
        ]:
            return

        future_invoices = []
        for preview_invoice in self.preview_invoices:
            start_date = datetime.strptime(
                preview_invoice["start_date"], "%Y-%m-%d"
            ).date()
            if not preview_invoice["start_date_has_passed"]:
                future_invoices.append(preview_invoice)

        if len(future_invoices) == 0:
            return

        for invoice in future_invoices:
            date_to_generate = datetime.strptime(
                invoice["original_issue_date"], "%d/%m/%Y"
            ).date()
            start_date = datetime.strptime(invoice["start_date"], "%Y-%m-%d").date()
            end_date = datetime.strptime(invoice["end_date"], "%Y-%m-%d").date()
            scheduled_invoice, created = ScheduledInvoice.objects.get_or_create(
                date_to_generate=date_to_generate,
                period_start_date=start_date,
                period_end_date=end_date,
                invoicing_details=self,
            )
            if created:
                logger.info(f"Scheduled invoice created: {scheduled_invoice}")

    def update_invoice_schedule(self):
        # Delete any future scheduled invoices
        ScheduledInvoice.objects.filter(
            invoicing_details=self,
            invoice__isnull=True,
            date_to_generate__gte=helpers.today(),
        ).delete()

        if self.charge_method.key in [
            settings.CHARGE_METHOD_NO_RENT_OR_LICENCE_CHARGE,
            settings.CHARGE_METHOD_ONCE_OFF_CHARGE,
            settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE,
            settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS,
        ]:
            return

        # Regenerate an invoice schedule for any future invoicing periods
        self.generate_invoice_schedule(invoiced_up_to=self.invoiced_up_to)

    def generate_immediate_invoices(self):
        """Generate invoices for the next invoicing period and any invoicing periods that have already passed
        This should only be run once when the finance officer has just finished "editing invoicing" on the
        application.
        """
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
        ):
            return
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE
        ):
            return self.generate_immediate_invoices_gross_turnover_advance()

        immediate_invoices = []
        for preview_invoice in self.preview_invoices:
            amount = preview_invoice["amount_object"]["amount"]
            if amount != Decimal("0.00") and preview_invoice["start_date_has_passed"]:
                immediate_invoices.append(preview_invoice)

        if len(immediate_invoices) == 0:
            return

        gst_free = self.approval.approval_type.gst_free

        generated_invoices = []

        for immediate_invoice in immediate_invoices:
            invoice = Invoice.objects.create(
                approval=self.approval,
                amount=immediate_invoice["amount_object"]["amount"],
                gst_free=gst_free,
                status=Invoice.INVOICE_STATUS_PENDING_UPLOAD_ORACLE_INVOICE,
            )
            generated_invoices.append(invoice)
            logger.info(f"Immediate invoice created: {invoice}")

        # send to the finance group so they can take action
        send_new_invoices_raised_internal_notification(generated_invoices)

    def generate_immediate_invoices_gross_turnover_advance(self):
        """Select any annual gross turnover estimate amounts that are not locked
        create an invoice for them and then lock them so they are not processed again.
        """

        immediate_invoices = []
        for preview_invoice in self.preview_invoices:
            amount = preview_invoice["amount_object"]["amount"]
            if (
                amount is not None
                and amount != Decimal("0.00")
                and preview_invoice["start_date_has_passed"]
            ):
                immediate_invoices.append(preview_invoice)

        gst_free = self.approval.approval_type.gst_free

        generated_invoices = []

        for immediate_invoice in immediate_invoices:
            invoice = Invoice.objects.create(
                approval=self.approval,
                amount=immediate_invoice["amount_object"]["amount"],
                gst_free=gst_free,
                status=Invoice.INVOICE_STATUS_PENDING_UPLOAD_ORACLE_INVOICE,
            )
            generated_invoices.append(invoice)
            logger.info(f"Immediate invoice created: {invoice}")

        # send to the finance group so they can take action
        send_new_invoices_raised_internal_notification(generated_invoices)

        # Lock the gross turnover estimates so they are not processed again
        self.gross_turnover_percentages.filter(
            estimated_gross_turnover__isnull=False, estimate_locked=False
        ).update(estimate_locked=True)

    def get_first_issue_date(self):
        first_issue_date = self.approval.start_date

        if (
            self.charge_method.key
            != settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS  # (Arrears)
        ):
            first_issue_date = first_issue_date - relativedelta(
                days=settings.DAYS_BEFORE_NEXT_INVOICING_PERIOD_TO_GENERATE_INVOICE_RECORD
            )

        return first_issue_date

    @property
    def next_issue_date(self):
        """Returns the next issue date based on the invoicing details object"""
        if not self.has_future_invoicing_periods:
            return None

        for issue_date_string in self.preview_invoices_issue_dates:
            try:
                issue_date = datetime.strptime(issue_date_string, "%d/%m/%Y").date()
            except ValueError:
                continue

            if issue_date > helpers.today():
                return issue_date_string

        return None

    def get_issue_date(
        self, amount_object, original_issue_date, issue_date_now_or_future, end_date
    ):
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
            and amount_object["amount"] is None
        ):
            end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
            q = utils.financial_quarter_from_date(end_date)
            financial_year = utils.financial_year_from_date(original_issue_date)
            if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_QUARTERLY:
                text = f"Q{q} {financial_year}"
            else:
                month = utils.month_string_from_date(end_date)
                text = f"{month} {end_date.year}"
            if utils.financial_year_has_passed(financial_year):
                return f"On entry of annual gross turnover from FY {financial_year} audited financial statement)"

            return f"On entry of gross turnover from {text} audited financial statement"

        return issue_date_now_or_future.strftime("%d/%m/%Y")

    def get_due_date(self, due_date):
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
        ):
            return "30 Days after issue"
        return due_date.strftime("%d/%m/%Y")

    def get_year_sequence_index(self, index):
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_ANNUALLY:
            return index
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_QUARTERLY:
            return math.floor(index / 4)
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_MONTHLY:
            return math.floor(index / (12 / self.invoicing_once_every))

    def get_amount_by_repetition_type(self, amount):
        # Modify the amount based on the invoicing repetition type
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_QUARTERLY:
            amount = amount / 4
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_MONTHLY:
            amount = amount / 12

        return amount.quantize(Decimal("0.01"))

    def get_amount_for_invoice(self, issue_date, start_date, end_date, days, index):
        amount_object = {
            "prefix": "$",
            "amount": Decimal("0.00"),
            "suffix": "",
        }
        if self.charge_method.key == settings.CHARGE_METHOD_ONCE_OFF_CHARGE:
            logger.warning(
                "To get the amount for a once off charge, simply access the once_off_charge_amount field"
            )
            amount_object["amount"] = self.once_off_charge_amount
            return amount_object

        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
        ):
            return self.get_amount_for_gross_turnover_in_arrears_invoice(
                end_date, amount_object
            )

        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE
        ):
            return self.get_amount_for_gross_turnover_in_advance_invoice(
                start_date, amount_object
            )

        if not self.base_fee_amount or self.base_fee_amount == Decimal("0.00"):
            amount_object["prefix"] = ""
            amount_object["amount"] = None
            amount_object["suffix"] = "Enter Base Fee"
            return amount_object

        base_fee_amount = self.base_fee_amount.quantize(Decimal("0.01"))

        period_contains_leap_year_day = utils.period_contains_leap_year_day(
            datetime.strptime(start_date, "%Y-%m-%d").date(),
            datetime.strptime(end_date, "%Y-%m-%d").date(),
        )

        # Ignore extra day in leap year so base fee is consistent
        if period_contains_leap_year_day:
            logger.debug(
                f"Ignoring extra day in leap year for period starting: {start_date} and ending: {end_date}"
            )
            days -= 1

        base_fee_amount = days * (
            base_fee_amount / 365
        )  # self.get_amount_by_repetition_type(base_fee_amount)

        if self.charge_method.key == settings.CHARGE_METHOD_BASE_FEE_PLUS_ANNUAL_CPI:
            start_date = datetime.strptime(start_date, "%Y-%m-%d").date()

            # If the start date is before the issue date, use the start date to calculate the cpi for that period
            # This is to cover the case of backdated invoices where using the issue date could yield a cpi figure
            # for a totally unrelated period.
            cpi_date = start_date if start_date < issue_date else issue_date
            cpi = ConsumerPriceIndex.get_most_recent_quarter_by_date(
                cpi_date, self.cpi_calculation_method.quarter
            )
            if cpi:
                amount_object["amount"] = Decimal(
                    base_fee_amount * (1 + cpi.value / 100)
                ).quantize(Decimal("0.01"))
                amount_object["suffix"] = f" (CPI: {cpi.value}%)"
            else:
                amount_object["amount"] = base_fee_amount
                amount_object["suffix"] = " + CPI (NYA)"
            return amount_object

        year_sequence_index = self.get_year_sequence_index(index)
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_BASE_FEE_PLUS_ANNUAL_CPI_CUSTOM
        ):
            amount_object["amount"] = base_fee_amount
            try:
                custom_cpi_year = self.custom_cpi_years.all()[year_sequence_index]
                if custom_cpi_year and custom_cpi_year.percentage:
                    amount_object["amount"] = Decimal(
                        base_fee_amount * (1 + custom_cpi_year.percentage / 100)
                    ).quantize(Decimal("0.01"))
                    amount_object["suffix"] = f" (CPI: {custom_cpi_year.percentage}%)"
                else:
                    amount_object["suffix"] = " + CPI (CUSTOM)"
            except IndexError:
                logger.warning(
                    f"Invoicing Details: {self.id} - No custom CPI year for index "
                    f"{year_sequence_index}. Using base fee amount."
                )

        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_BASE_FEE_PLUS_FIXED_ANNUAL_PERCENTAGE
        ):
            percentage = Decimal("0.00")
            suffix = (
                f"Enter percentage for year {year_sequence_index + 1}"
                if year_sequence_index > 0
                else ""
            )
            if year_sequence_index > 0:
                try:
                    annual_increment_percentage = (
                        self.annual_increment_percentages.all()[year_sequence_index - 1]
                    )
                    percentage = annual_increment_percentage.increment_percentage
                    if not percentage:
                        percentage = Decimal("0.00")
                    base_fee_amount = base_fee_amount * (1 + percentage / 100)
                    suffix = ""
                except IndexError:
                    if (
                        not self.invoicing_repetition_type.key
                        == settings.REPETITION_TYPE_ANNUALLY
                    ):
                        # There can be a situation when an approval that lasts say 5 years for example
                        # When converted to quarters or months results in a year_sequence_index that is out of range
                        suffix = ""
                    logger.warning(
                        f"Invoicing Details: {self.id} - No annual increment percentage for index "
                        f"{index}. Using base fee amount."
                    )

            amount_object["amount"] = Decimal(base_fee_amount).quantize(Decimal("0.01"))
            amount_object["suffix"] = suffix

        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_BASE_FEE_PLUS_FIXED_ANNUAL_INCREMENT
        ):
            increment_amount = Decimal("0.00")
            suffix = (
                f"Enter increment amount for year {year_sequence_index + 1}"
                if year_sequence_index > 0
                else ""
            )
            if year_sequence_index > 0:
                try:
                    annual_increment_amount = self.annual_increment_amounts.all()[
                        year_sequence_index - 1
                    ]
                    if annual_increment_amount:
                        if annual_increment_amount.increment_amount:
                            increment_amount = annual_increment_amount.increment_amount
                            increment_amount = self.get_amount_by_repetition_type(
                                increment_amount
                            )
                        base_fee_amount = base_fee_amount + increment_amount
                        suffix = ""
                except IndexError:
                    if (
                        not self.invoicing_repetition_type.key
                        == settings.REPETITION_TYPE_ANNUALLY
                    ):
                        # There can be a situation when an approval that lasts say 5 years for example
                        # When converted to quarters or months results in a year_sequence_index that is out of range
                        suffix = ""
                    logger.warning(
                        f"Invoicing Details: {self.id} - No annual increment amount for index "
                        f"{index}. Using base fee amount."
                    )

            amount_object["amount"] = Decimal(base_fee_amount).quantize(Decimal("0.01"))
            amount_object["suffix"] = suffix

        amount_object["amount"] = amount_object["amount"].quantize(Decimal("0.01"))

        return amount_object

    def get_amount_for_gross_turnover_in_arrears_invoice(self, end_date, amount_object):
        amount_object["prefix"] = ""
        amount_object["amount"] = None
        end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
        financial_year = utils.financial_year_from_date(end_date)
        year = int(financial_year.split("-")[1])
        gross_turnover_percentage = next(
            (x for x in self.gross_turnover_percentages.all() if x.year == year), None
        )
        if not gross_turnover_percentage:
            amount_object["suffix"] = "???"
            return amount_object

        if gross_turnover_percentage.gross_turnover:
            amount = Decimal(
                gross_turnover_percentage.gross_turnover
                * gross_turnover_percentage.percentage
                / 100
            )
            amount = self.get_amount_by_repetition_type(amount)
            amount_object["prefix"] = "$"
            amount_object["amount"] = amount
            return amount_object

        amount_object["suffix"] = (
            f"{gross_turnover_percentage.percentage}% of Gross Turnover"
        )
        return amount_object

    def get_amount_for_gross_turnover_in_advance_invoice(
        self, start_date, amount_object
    ):
        amount_object["prefix"] = ""
        amount_object["amount"] = None

        if not self.gross_turnover_percentages.filter(
            Q(estimated_gross_turnover__isnull=False) | Q(gross_turnover__isnull=False)
        ).exists():
            amount_object["suffix"] = (
                "No gross turnover estimate or gross turnover actual entered"
            )
            return amount_object

        start_date = datetime.strptime(start_date, "%Y-%m-%d").date()

        year = utils.financial_year_from_date(start_date).split("-")[1]

        gross_turnover_percentage = self.gross_turnover_percentages.filter(
            year=year
        ).first()

        if not gross_turnover_percentage:
            logger.error(f"No gross turnover percentage found for year {year}")
            raise serializers.ValidationError(
                f"No gross turnover percentage found for year {year}"
            )

        estimated_or_actual_gross_turnover = (
            gross_turnover_percentage.gross_turnover
            if gross_turnover_percentage.gross_turnover
            else gross_turnover_percentage.estimated_gross_turnover
        )

        if not estimated_or_actual_gross_turnover:
            amount_object["suffix"] = (
                "No estimated gross turnover or actual gross turnover entered "
                "(Enter at a later date to generate an invoice)"
            )
            return amount_object

        percentage = gross_turnover_percentage.percentage
        if not percentage:
            percentage = Decimal("0.00")

        invoice_amount = Decimal(
            estimated_or_actual_gross_turnover * percentage / 100
        ).quantize(Decimal("0.01"))

        amount_object["prefix"] = "$"

        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_QUARTERLY:
            amount_object["amount"] = Decimal(invoice_amount / 4).quantize(
                Decimal("0.01")
            )

        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_MONTHLY:
            amount_object["amount"] = Decimal(invoice_amount / 12).quantize(
                Decimal("0.01")
            )

        return amount_object

    def get_end_of_next_interval(self, start_date):
        if self.charge_method.key in [
            settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS,
            settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE,
        ]:
            return self.get_end_of_next_interval_gross_turnover(start_date)

        # All other charge methods are based around each year of the duration of the lease/license
        # Which is being referred to as 'sequential year'
        return self.get_end_of_next_interval_sequential_year(start_date)

    def get_end_of_next_interval_sequential_year(self, start_date):
        if settings.REPETITION_TYPE_ANNUALLY == self.invoicing_repetition_type.key:
            return start_date + relativedelta(years=1) - relativedelta(days=1)

        if settings.REPETITION_TYPE_QUARTERLY == self.invoicing_repetition_type.key:
            return start_date + relativedelta(months=3) - relativedelta(days=1)

        if settings.REPETITION_TYPE_MONTHLY == self.invoicing_repetition_type.key:
            return (
                start_date
                + relativedelta(months=self.invoicing_once_every)
                - relativedelta(days=1)
            )

    def get_end_of_next_interval_gross_turnover(self, start_date):
        if settings.REPETITION_TYPE_ANNUALLY == self.invoicing_repetition_type.key:
            return utils.end_of_next_financial_year(start_date)

        if settings.REPETITION_TYPE_QUARTERLY == self.invoicing_repetition_type.key:
            return utils.end_of_next_financial_quarter(
                start_date, start_month=self.invoicing_quarters_start_month
            )

        if settings.REPETITION_TYPE_MONTHLY == self.invoicing_repetition_type.key:
            return utils.end_of_month(start_date)

    def add_repetition_interval(self, issue_date):
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_ANNUALLY:
            return issue_date + relativedelta(years=1)
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_QUARTERLY:
            return issue_date + relativedelta(months=3)
        if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_MONTHLY:
            return issue_date + relativedelta(months=self.invoicing_once_every)

    @transaction.atomic
    def process_gross_turnover_invoices(self):
        if (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
        ):
            return self.process_gross_turnover_invoices_arrears()
        elif (
            self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE
        ):
            return self.process_gross_turnover_invoices_advance()
        else:
            return

    def process_gross_turnover_invoices_arrears(self):
        """Select any annual, quarterly or monthly gross turnover amounts that are not locked
        create an invoice for them and then lock them so they are not processed again.
        """
        gst_free = self.approval.approval_type.gst_free

        gross_turnover_percentages = self.gross_turnover_percentages.filter(
            locked=False
        )
        for gross_turnover_percentage in gross_turnover_percentages:
            if gross_turnover_percentage.gross_turnover is not None:
                if (
                    gross_turnover_percentage.discrepency
                    and gross_turnover_percentage.discrepency != Decimal("0.00")
                ):
                    invoice = Invoice.objects.create(
                        approval=self.approval,
                        amount=gross_turnover_percentage.discrepency_invoice_amount,
                        gst_free=gst_free,
                    )

                    # Send email to notify finance group users
                    send_new_invoice_raised_internal_notification(invoice)

                gross_turnover_percentage.locked = True
                gross_turnover_percentage.save()

            if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_QUARTERLY:
                quarters = gross_turnover_percentage.quarters.filter(
                    gross_turnover__isnull=False, locked=False
                )
                for quarter in quarters:
                    amount = quarter.gross_turnover * (
                        gross_turnover_percentage.percentage / 100
                    )
                    if amount == Decimal("0.00"):
                        continue

                    invoice = Invoice.objects.create(
                        approval=self.approval, amount=amount, gst_free=gst_free
                    )

                    # Send email to notify finance group users
                    send_new_invoice_raised_internal_notification(invoice)

                quarters.update(locked=True)

            if self.invoicing_repetition_type.key == settings.REPETITION_TYPE_MONTHLY:
                months = gross_turnover_percentage.months.filter(
                    gross_turnover__isnull=False, locked=False
                )
                for month in months:
                    amount = month.gross_turnover * (
                        gross_turnover_percentage.percentage / 100
                    )
                    if amount == Decimal("0.00"):
                        continue

                    invoice = Invoice.objects.create(
                        approval=self.approval, amount=amount, gst_free=gst_free
                    )

                    # Send email to notify finance group users
                    send_new_invoice_raised_internal_notification(invoice)

                months.update(locked=True)

    def process_gross_turnover_invoices_advance(self):
        gst_free = self.approval.approval_type.gst_free

        gross_turnover_percentages = self.gross_turnover_percentages.filter(
            estimated_gross_turnover__isnull=False, estimate_locked=False
        )
        logger.debug(
            f"Found {gross_turnover_percentages.count()} gross turnover estimates"
        )
        for gross_turnover_percentage in gross_turnover_percentages:
            if not utils.financial_year_has_passed(
                gross_turnover_percentage.financial_year
            ):
                # Future invoices will be generated by the scheduled invoice process
                # on a quarterly or monthly basis
                continue

            # Deal with cases where just an estimate has been entered
            amount = gross_turnover_percentage.estimated_gross_turnover * (
                gross_turnover_percentage.percentage / 100
            )
            if amount == Decimal("0.00"):
                continue

            invoice = Invoice.objects.create(
                approval=self.approval, amount=amount, gst_free=gst_free
            )

            # Send email to notify finance group users
            send_new_invoice_raised_internal_notification(invoice)

        gross_turnover_percentages.update(estimate_locked=True)

        gross_turnover_percentages = self.gross_turnover_percentages.filter(
            gross_turnover__isnull=False, locked=False
        )
        for gross_turnover_percentage in gross_turnover_percentages:
            # Deal with cases where an estimate and actual have been entered
            if (
                gross_turnover_percentage.discrepency
                and gross_turnover_percentage.discrepency != Decimal("0.00")
            ):
                invoice = Invoice.objects.create(
                    approval=self.approval,
                    amount=gross_turnover_percentage.discrepency_invoice_amount,
                    gst_free=gst_free,
                )

                # Send email to notify finance group users
                send_new_invoice_raised_internal_notification(invoice)

        gross_turnover_percentages.update(locked=True)

    def turnover_entry_reminder_required(self, days_prior):
        if (
            not self.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE
        ):
            return False
        if not self.has_future_invoicing_periods:
            return False

        if not self.gross_turnover_percentages.filter(
            estimated_gross_turnover__isnull=True, gross_turnover__isnull=True
        ).exists():
            return False

        potential_issue_date = timezone.now().date() + relativedelta(days=days_prior)

        for invoice in self.preview_invoices:
            if not invoice["amount_object"]["amount"] is None:
                continue

            issue_date = datetime.strptime(invoice["issue_date"], "%d/%m/%Y").date()
            # logger.debug(f"potential_issue_date: {potential_issue_date}, issue_date: {issue_date}")
            if issue_date == potential_issue_date:
                return True

    def reset_gto_amounts(self):
        # Used to speed up testing only
        if not settings.DEBUG:
            return

        for gross_turnover_percentage in self.gross_turnover_percentages.all():
            gross_turnover_percentage.estimated_gross_turnover = None
            gross_turnover_percentage.gross_turnover = None
            gross_turnover_percentage.estimate_locked = False
            gross_turnover_percentage.locked = False
            gross_turnover_percentage.save()

            for quarter in gross_turnover_percentage.quarters.all():
                quarter.gross_turnover = None
                quarter.locked = False
                quarter.save()

            for month in gross_turnover_percentage.months.all():
                month.gross_turnover = None
                month.locked = False
                month.save()

        self.approval.invoices.all().delete()


class ScheduledInvoice(BaseModel):
    """
    Not to be confused with the Invoice model (further down)

    Used to keep track of when invoices need to be generated, if they have been generated
    and if they have been sent to the internal and external user.

    The amount for the invoice is still calculated dynamically as it may change over time depending
    on what data has been entered by the finance officer group members."""

    date_to_generate = models.DateField(null=False, blank=False)
    period_start_date = models.DateField(null=False, blank=False)
    period_end_date = models.DateField(null=False, blank=False)
    attempts_to_send_notification_email = models.PositiveSmallIntegerField(default=0)
    notification_email_sent = models.BooleanField(default=False)
    invoicing_details = models.ForeignKey(
        InvoicingDetails,
        on_delete=models.CASCADE,
        related_name="scheduled_invoices",
    )

    class Meta:
        app_label = "leaseslicensing"
        ordering = [
            "date_to_generate",
        ]

    def __str__(self):
        if hasattr(self, "invoice"):
            return (
                f"Scheduled Invoice: {self.id} for Approval {self.invoicing_details.proposal.approval} "
                f"generated Invoice: {self.invoice.lodgement_number} on {self.date_to_generate}"
            )
        if self.date_to_generate > helpers.today():
            return (
                f"Scheduled Invoice: {self.id} for Approval {self.invoicing_details.proposal.approval} "
                f"scheduled to generate invoice on {self.date_to_generate}"
            )
        return (
            f"Scheduled Invoice: {self.id} for Approval {self.invoicing_details.proposal.approval} "
            f"was scheduled to generate invoice on {self.date_to_generate} (next attempt tomorrow)"
        )


class FixedAnnualIncrementAmount(BaseModel):
    year = models.PositiveSmallIntegerField(null=True, blank=True)
    increment_amount = models.DecimalField(
        max_digits=10, decimal_places=2, default="0.00", null=True, blank=True
    )
    invoicing_details = models.ForeignKey(
        InvoicingDetails,
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="annual_increment_amounts",
    )

    class Meta:
        app_label = "leaseslicensing"
        ordering = [
            "year",
        ]
        unique_together = (
            "year",
            "invoicing_details",
        )

    def __str__(self):
        return f"Year: {self.year}, Increment Amount: {self.increment_amount}"


class FixedAnnualIncrementPercentage(BaseModel):
    year = models.PositiveSmallIntegerField(null=True, blank=True)
    increment_percentage = models.DecimalField(
        max_digits=4,
        decimal_places=1,
        default="0.0",
        blank=True,
        null=True,
    )
    invoicing_details = models.ForeignKey(
        InvoicingDetails,
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="annual_increment_percentages",
    )

    class Meta:
        app_label = "leaseslicensing"
        ordering = [
            "year",
        ]
        unique_together = (
            "year",
            "invoicing_details",
        )

    def __str__(self):
        return f"Year: {self.year}, Increment Percentage: {self.increment_percentage}"


class PercentageOfGrossTurnover(BaseModel):
    year = models.PositiveSmallIntegerField(null=True, blank=True)
    percentage = models.DecimalField(
        max_digits=4, decimal_places=1, default="0.0", null=True, blank=True
    )
    estimated_gross_turnover = models.DecimalField(
        null=True, blank=True, max_digits=15, decimal_places=2
    )
    gross_turnover = models.DecimalField(
        null=True, blank=True, max_digits=15, decimal_places=2
    )
    invoicing_details = models.ForeignKey(
        InvoicingDetails,
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="gross_turnover_percentages",
    )
    estimate_locked = models.BooleanField(default=False)
    locked = models.BooleanField(default=False)

    class Meta:
        app_label = "leaseslicensing"
        ordering = [
            "year",
        ]
        unique_together = (
            "year",
            "invoicing_details",
        )

    def __str__(self):
        return f"{self.year}: {self.percentage}%"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)

    @property
    def financial_year(self):
        return f"{self.year-1}-{self.year}"

    @property
    def financial_year_has_passed(self):
        return utils.financial_year_has_passed(self.financial_year)

    @property
    def discrepency(self):
        if not self.gross_turnover:
            return None

        if (
            self.invoicing_details.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ARREARS
        ):
            sum_of_quarters = self.quarters.aggregate(sum=Sum("gross_turnover"))["sum"]
            if not sum_of_quarters:
                # For back dated financial years, there are no quarters entered so there will not be a discrepency
                sum_of_quarters = Decimal("0.00")
            discrepency = self.gross_turnover - sum_of_quarters

        if (
            self.invoicing_details.charge_method.key
            == settings.CHARGE_METHOD_PERCENTAGE_OF_GROSS_TURNOVER_IN_ADVANCE
        ):
            if not self.estimated_gross_turnover:
                return None

            discrepency = self.gross_turnover - self.estimated_gross_turnover

        return discrepency.quantize(Decimal("0.01"))

    @property
    def discrepency_invoice_amount(self):
        if not self.gross_turnover:
            return None

        if not self.discrepency:
            return None

        discrepency_invoice_amount = self.discrepency * (self.percentage / 100)

        return discrepency_invoice_amount.quantize(Decimal("0.01"))

    @property
    def discrepency_invoice_type(self):
        if not self.gross_turnover:
            return None

        if not self.discrepency:
            return None

        if self.discrepency > 0:
            return "Credit"

        return "Debit"


class FinancialQuarter(BaseModel):
    year = models.ForeignKey(
        PercentageOfGrossTurnover,
        on_delete=models.CASCADE,
        related_name="quarters",
    )
    quarter = models.PositiveSmallIntegerField(
        null=True, blank=True, validators=[MinValueValidator(1), MaxValueValidator(4)]
    )
    gross_turnover = models.DecimalField(
        null=True, blank=True, max_digits=15, decimal_places=2
    )
    locked = models.BooleanField(default=False)

    class Meta:
        app_label = "leaseslicensing"
        ordering = [
            "year",
            "quarter",
        ]

    def __str__(self):
        return f"Q{self.quarter} {self.year}: Gross Turnover: {self.gross_turnover or 'Not yet entered'}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)


class FinancialMonth(BaseModel):
    financial_year = models.ForeignKey(
        PercentageOfGrossTurnover,
        on_delete=models.CASCADE,
        related_name="months",
    )
    month = models.PositiveSmallIntegerField(
        null=False,
        blank=False,
        validators=[MinValueValidator(1), MaxValueValidator(12)],
    )
    year = models.PositiveSmallIntegerField(
        null=False,
        blank=False,
        validators=[MinValueValidator(1950), MaxValueValidator(9999)],
    )
    gross_turnover = models.DecimalField(
        null=True, blank=True, max_digits=15, decimal_places=2
    )
    locked = models.BooleanField(default=False)

    class Meta:
        app_label = "leaseslicensing"
        ordering = [
            "year",
            "month",
        ]

    @property
    def month_name(self):
        return utils.month_string_from_month(self.month)

    def __str__(self):
        return f"{self.month_name} {self.year}: Gross Turnover: {self.gross_turnover or 'Not yet entered'}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)


class CustomCPIYear(BaseModel):
    year = models.PositiveSmallIntegerField()
    label = models.CharField(max_length=100, null=True, blank=True)
    # Do not default percentage to Decimal("0.00") as it is possible for the inflation figure to be 0
    percentage = models.DecimalField(
        max_digits=4, decimal_places=1, null=True, blank=True
    )
    invoicing_details = models.ForeignKey(
        InvoicingDetails,
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="custom_cpi_years",
    )

    class Meta:
        app_label = "leaseslicensing"
        ordering = ["invoicing_details", "year"]

    def __str__(self):
        return f"{self.year}: {self.percentage}%"


def invoice_pdf_upload_path(instance, filename):
    return f"approvals/{instance.approval.id}/invoices/{instance.id}/{filename}"


class InvoiceManager(models.Manager):
    def get_queryset(self):
        return (
            super()
            .get_queryset()
            .select_related("approval")
            .prefetch_related("transactions")
        )


class Invoice(LicensingModel):
    objects = InvoiceManager()

    MODEL_PREFIX = "I"

    INVOICE_STATUS_PENDING_UPLOAD_ORACLE_INVOICE = "pending_upload_oracle_invoice"
    INVOICE_STATUS_UNPAID = "unpaid"
    INVOICE_STATUS_PAID = "paid"
    INVOICE_STATUS_VOID = "void"
    INVOICE_STATUS_DISCARDED = "discarded"
    INVOICE_STATUS_CHOICES = (
        (
            INVOICE_STATUS_PENDING_UPLOAD_ORACLE_INVOICE,
            "Pending Upload of Oracle Invoice",
        ),
        (INVOICE_STATUS_UNPAID, "Unpaid"),
        (INVOICE_STATUS_PAID, "Paid"),
        (INVOICE_STATUS_VOID, "Void"),
        (INVOICE_STATUS_DISCARDED, "Discarded"),
    )
    approval = models.ForeignKey(
        "Approval",
        blank=False,
        null=False,
        on_delete=models.PROTECT,
        related_name="invoices",
    )
    status = models.CharField(
        max_length=40,
        choices=INVOICE_STATUS_CHOICES,
        default=INVOICE_STATUS_PENDING_UPLOAD_ORACLE_INVOICE,
        null=True,
        blank=True,
    )
    amount = models.DecimalField(max_digits=12, decimal_places=2, null=True, blank=True)
    gst_free = models.BooleanField(default=False)
    datetime_created = models.DateTimeField(auto_now_add=True, null=False)
    datetime_updated = models.DateTimeField(auto_now=True, null=False)
    date_paid = models.DateField(null=True, blank=False)
    date_issued = models.DateField(null=True, blank=False)
    date_due = models.DateField(null=True, blank=False)
    proponent_reference_number = models.CharField(null=True, blank=True, max_length=50)

    # Fields that will match those in the ledger system
    order_number = models.CharField(unique=True, max_length=128, blank=False, null=True)
    basket_id = models.IntegerField(unique=True, blank=False, null=True)
    invoice_reference = models.CharField(
        unique=True, max_length=36, blank=False, null=True
    )

    # Why uuid? We need a unique identifier that is not
    # easily guessable for the ledger checkout callback api
    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)

    # Not sure if we will need this, the invoice file may exist within ledger
    invoice_pdf = SecureFileField(
        upload_to=invoice_pdf_upload_path, null=True, blank=True
    )
    oracle_invoice_number = models.CharField(
        unique=True, max_length=50, null=True, blank=True
    )
    description = models.TextField(null=True, blank=True)
    ad_hoc = models.BooleanField(default=False)
    scheduled_invoice = models.OneToOneField(
        ScheduledInvoice,
        null=True,
        blank=True,
        on_delete=models.PROTECT,
        related_name="invoice",
    )
    oracle_code = models.ForeignKey(
        OracleCode,
        null=True,
        blank=True,
        on_delete=models.PROTECT,
    )

    class Meta:
        app_label = "leaseslicensing"
        ordering = ["-date_issued", "approval"]

    def __str__(self):
        return (
            f"Invoice: {self.lodgement_number} for Approval: {self.approval} "
            f"of Amount: {self.amount} with Status: {self.status}"
        )

    def user_has_object_permission(self, user_id):
        return self.approval.user_has_object_permission(user_id)

    def save(self, *args, **kwargs):
        # If the invoice is being created without an oracle code
        # and the invoicing details has an oracle code, use that instead
        # This allows the user to not have to enter the oracle code twice
        # but have the option to override it if they want to
        if not self.oracle_code and self.invoicing_details.oracle_code:
            self.oracle_code = self.invoicing_details.oracle_code
        super().save(*args, **kwargs)

    @property
    def balance(self):
        amount = self.amount
        if not amount:
            amount = Decimal("0.00")

        credit_debit_sums = self.transactions.aggregate(
            credit=Coalesce(models.Sum("credit"), Decimal("0.00")),
            debit=Coalesce(models.Sum("debit"), Decimal("0.00")),
        )
        balance = amount + credit_debit_sums["credit"] - credit_debit_sums["debit"]
        return Decimal(balance).quantize(Decimal("0.01"))

    @property
    def invoicing_details(self):
        return self.approval.current_proposal.invoicing_details

    @property
    def ledger_invoice_url(self):
        if not self.invoice_reference:
            return None
        return (
            settings.LEDGER_API_URL
            + "/ledgergw/invoice-pdf/"
            + settings.LEDGER_API_KEY
            + "/"
            + self.invoice_reference
        )

    @property
    def gst(self):
        gst = Decimal("0.00")
        if not self.gst_free:
            gst = helpers.gst_from_total(self.amount)
        return gst

    @property
    def amount_excl_gst(self):
        return self.amount - self.gst

    def purge_invoice(self):
        if not settings.DEBUG:
            raise ValidationError("This method is only for use in DEBUG mode")
        self.transactions.all().delete()
        self.delete()


class InvoiceTransactionManager(models.Manager):
    def get_queryset(self):
        return (
            super()
            .get_queryset()
            .annotate(
                cumulative_balance=Window(
                    expression=Sum("debit"),
                    order_by=F("datetime_created").asc(),
                )
                - Window(
                    expression=Sum("credit"),
                    order_by=F("datetime_created").asc(),
                )
            )
        )


class InvoiceTransaction(RevisionedMixin, models.Model):
    objects = InvoiceTransactionManager()
    invoice = models.ForeignKey(
        Invoice,
        on_delete=models.PROTECT,
        related_name="transactions",
        null=False,
        blank=False,
    )
    credit = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        blank=False,
        null=False,
        default=Decimal("0.00"),
    )
    debit = models.DecimalField(
        max_digits=12,
        decimal_places=2,
        blank=False,
        null=False,
        default=Decimal("0.00"),
    )
    datetime_created = models.DateTimeField(auto_now_add=True)
    datetime_updated = models.DateTimeField(auto_now=True)

    class Meta:
        app_label = "leaseslicensing"
        ordering = ["datetime_created"]

    def __str__(self):
        return f"Transaction: {self.id} for Invoice: {self.invoice} Credit: {self.credit}, Debit: {self.debit}"
